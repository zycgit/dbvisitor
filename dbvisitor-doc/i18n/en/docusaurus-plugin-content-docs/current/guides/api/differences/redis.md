---
id: redis
sidebar_position: 1
hide_table_of_contents: true
title: Redis Specifics
description: Capabilities and limitations of using dbVisitor with a Redis data source.
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip[Hint]
This article is generated by AI translation.
:::

# Redis Datasource Specifics

dbVisitor accesses Redis data sources via the [JDBC-Redis](../../../drivers/redis/about) driver, based on the JDBC protocol.

**Supported capabilities:**
- Execute Redis commands to manipulate data ([supported command list](../../../drivers/redis/commands))
- [JdbcTemplate](#exec-command), [Annotations](#exec-annotation), [Mapper File](#exec-file) — three usage methods
- [Rules](../../rules/about), [Arguments](../../args/about), [ResultSetExtractor/RowMapper](../../result/about) and other general capabilities
- [Dynamic SQL](../../core/file/dynamic) tags in Mapper Files

**Not supported:** Fluent API, BaseMapper, Object Mapping, ResultSet Mapping, executeBatch, stored procedures

## Concept Analogy

Different Redis commands produce three types of results:
- **Update count** — analogous to INSERT/UPDATE/DELETE, retrieved via `executeUpdate`
- **Single/multiple row results** — analogous to SELECT result sets

---

## Command Mode (JdbcTemplate) {#exec-command}

Use JdbcTemplate to execute Redis commands directly. Ensure you have properly configured the Redis data source first — see [Redis Driver Usage Guide](../../../drivers/redis/usecase).

:::tip[Tip]
For more usage patterns, see [JdbcTemplate](../../core/jdbc/about#guide). The following features are not supported due to driver limitations:
- Batch operations
- Stored procedures
:::

```java title='Create JdbcTemplate'
JdbcTemplate jdbc = new JdbcTemplate(dataSource);
// or
JdbcTemplate jdbc = new JdbcTemplate(connection);
```

### Key Read/Write/Delete

```java title='Read Key'
// Direct command
String result1 = jdbc.queryForString("GET myKey");
// Parameterized command
String result2 = jdbc.queryForString("GET ?", "myKey");
```

```java title='Write Key'
// Direct command
int result1 = jdbc.executeUpdate("SET myKey myValue");
// Parameterized command
int result2 = jdbc.executeUpdate("SET ? ?", new Object[] { "myKey", "myValue" });
```

```java title='Delete Key'
// Direct command
int result1 = jdbc.executeUpdate("DEL myKey");
// Parameterized command
int result2 = jdbc.executeUpdate("DEL ?", "myKey");
```

### Key Read/Write/Delete (Multiple Keys)

```java title='Read multiple Keys'
Map<String, Integer> result = jdbc.queryForPairs("MGET ? ? ?", String.class, Integer.class,
                                                  new Object[] { "key1", "key2", "key3" });
```

```java title='Write multiple Keys'
int result = jdbc.executeUpdate("MSET ? ? ? ? ? ?",
                                new Object[] { "key1", "value1", "key2", "value2", "key3", "value3" });
```

```java title='Delete multiple Keys'
int result = jdbc.executeUpdate("DEL ? ? ?", new Object[] { "key1", "key2", "key3" });
```

### Object Read/Write

```java title='Bind JSON serialization with @BindTypeHandler'
@BindTypeHandler(JsonTypeHandler.class)
public class MyObject {
    ...
}
```

```java title='Read/write objects'
// Read object
MyObject obj = jdbc.queryForObject("GET ?", MyObject.class, "myObjectKey");
// Write object
jdbc.executeUpdate("SET ? ?", new Object[] { "myObjectKey", (MyObject) myObject });
```

---

## Annotations {#exec-annotation}

:::tip[Tip]
All [annotations provided by the core API](../../core/annotation/about) work on Redis data sources, except for the `@Call` annotation.
:::

```java title='1. Define object with JSON serialization'
@BindTypeHandler(JsonTypeHandler.class)
public class UserInfo {
    private String uid;
    private String name;
    ... // getters/setters omitted
}
```

```java title='2. Define Mapper interface'
// Key name uses prefix "user_" combined with UID for storing/retrieving user info
@SimpleMapper()
public interface UserInfoMapper {
    @Insert("set #{'user_' + info.uid} #{info}")
    int saveUser(@Param("info") UserInfo info);

    @Query("get #{'user_' + uid}")
    UserInfo loadUser(@Param("uid") String uid);

    @Delete("del #{'user_' + uid}")
    int deleteUser(@Param("uid") String uid);
}
```

```java title='3. Create and use Mapper'
Configuration config = new Configuration();
Session session = config.newSession(dataSource);

UserInfoMapper mapper = session.createMapper(UserInfoMapper.class);
```

---

## File Mode (Mapper File) {#exec-file}

:::tip[Tip]
In XML Mapper files, when configuring object serialization mapping via the select tag, the `resultType` attribute must be specified to correctly discover the `BindTypeHandler` annotation on the object.
:::

<Tabs>
    <TabItem value="a" label="Approach 1: Using BindTypeHandler Annotation" default>

        ```java title='1. Define object with JSON serialization'
        @BindTypeHandler(JsonTypeHandler.class)
        public class UserInfo {
            private String uid;
            private String name;

            ... // getters/setters omitted
        }
        ```

        ```xml title='2. Define Mapper file'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE mapper PUBLIC "-//dbvisitor.net//DTD Mapper 1.0//EN"
        "https://www.dbvisitor.net/schema/dbvisitor-mapper.dtd">
        <mapper namespace="net.test.dto.UserInfoMapper">
            <insert id="saveUser">
                set #{'user_' + uid} #{info}
            </insert>

            <select id="loadUser" resultType="net.test.dto.UserInfo">
                get #{'user_' + uid}
            </select>

            <delete id="deleteUser">
                del #{'user_' + uid}
            </delete>
        </mapper>
        ```

    </TabItem>
    <TabItem value="b" label="Approach 2: Non-Intrusive">

        ```java title='1. Define object without BindTypeHandler annotation'
        public class UserInfo {
            private String uid;
            private String name;

            ... // getters/setters omitted
        }
        ```

        ```xml title='2. Define Mapper file'
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE mapper PUBLIC "-//dbvisitor.net//DTD Mapper 1.0//EN"
        "https://www.dbvisitor.net/schema/dbvisitor-mapper.dtd">
        <mapper namespace="net.test.dto.UserInfoMapper">
            <insert id="saveUser">
                set #{'user_' + uid}
                #{info, typeHandler=net.hasor.dbvisitor.types.handler.json.JsonTypeHandler}
            </insert>

            <!-- Need to specify both resultTypeHandler and resultType attributes -->
            <select id="loadUser1"
                    resultTypeHandler="net.hasor.dbvisitor.types.handler.json.JsonTypeHandler"
                    resultType="net.test.dto.UserInfo">
                get #{'user_' + uid}
            </select>

            <select id="loadUser2" resultType="net.test.dto.UserInfo">
                get #{'user_' + uid}
            </select>

            <delete id="deleteUser">
                del #{'user_' + uid}
            </delete>
        </mapper>
        ```

    </TabItem>
</Tabs>

```java title='3. Define Mapper interface'
@RefMapper("dbvisitor/mapper/UserInfoMapper.xml")
public interface UserInfoMapper {
    int saveUser(@Param("info") UserInfo info);

    UserInfo loadUser(@Param("uid") String uid);

    int deleteUser(@Param("uid") String uid);
}
```

```java title='4. Create and use Mapper'
Configuration config = new Configuration();
Session session = config.newSession(dataSource);

UserInfoMapper mapper = session.createMapper(UserInfoMapper.class);
```

---

## Redis Data Type Operations {#redis-type}

Redis has 5 main data types. Below is how to use dbVisitor for read/write operations on each type.

:::tip[Tip]
Redis main data type command reference: [String](../../../drivers/redis/commands#string), [Hash](../../../drivers/redis/commands#hash), [List](../../../drivers/redis/commands#list), [Set](../../../drivers/redis/commands#set), [SortedSet](../../../drivers/redis/commands#storeset)
:::

### String {#string}

```java title="Read/write strings via GET/SET commands"
jdbc.executeUpdate("SET ? ?", new Object[] { "myKey", "myValue" });
String value = jdbc.queryForString("GET ?", "myKey");
```

```java title="Set expiration time when writing"
jdbc.executeUpdate("SETEX ? ? ?", new Object[] { "myKey", 60, "myValue" });
jdbc.executeUpdate("SET ? ? EX ?", new Object[] { "myKey", "myValue", 60 });
```
- Reference: [SET command](https://redis.io/docs/latest/commands/set/)

```java title="Increment/decrement numeric values via INCR/DECR commands"
jdbc.executeUpdate("SET myKey 0");                      // Initial value 0
String result = jdbc.queryForString("INCR ?", "myKey"); // Value after increment: 1
String result = jdbc.queryForString("DECR ?", "myKey"); // Value after decrement: 0
```
- Reference: [INCR command](https://redis.io/docs/latest/commands/incr/), [DECR command](https://redis.io/docs/latest/commands/decr/)

```java title="Append/substring via APPEND/GETRANGE commands"
jdbc.executeUpdate("SET myKey myValue");                                              // Initial value: myValue
String result = jdbc.queryForString("APPEND ? ?", new Object[] { "myKey", "123" });   // After append: myValue123
String result = jdbc.queryForString("GETRANGE ? ? ?", new Object[] { "myKey", 0, 5 });// After substring: myVal
```
- Reference: [APPEND command](https://redis.io/docs/latest/commands/append/), [GETRANGE command](https://redis.io/docs/latest/commands/getrange/)

```java title="Read/write objects using JSON serialization"
// MyObject type needs to be annotated with @BindTypeHandler(JsonTypeHandler.class)
jdbc.queryForObject("GET myObjectKey", MyObject.class);
jdbc.executeUpdate("SET myObjectKey ?", (MyObject) myObject);
```
- Reference: [GET command](https://redis.io/docs/latest/commands/get/), [SET command](https://redis.io/docs/latest/commands/set/)

### Hash {#hash}

```java title="Read/write hash fields via HSET/HGET commands"
jdbc.executeUpdate("HSET myHashKey field1 value1");
jdbc.queryForString("HGET ? ?", new Object[] { "myHashKey", "field1" });
```
- Reference: [HSET command](https://redis.io/docs/latest/commands/hset/), [HGET command](https://redis.io/docs/latest/commands/hget/)

```java title="Read all fields under a hash key via HKEYS command"
List<String> keys = jdbc.queryForList("HKEYS myHashKey", String.class);
```
- Reference: [HKEYS command](https://redis.io/docs/latest/commands/hkeys/)

```java title="Read all fields and values under a hash key via HGETALL command"
Map<String, String> hashFields = jdbc.queryForPairs("HGETALL myHashKey", String.class, String.class);
```
- Reference: [HGETALL command](https://redis.io/docs/latest/commands/hgetall/)

```java title="Persist a Map to a hash key using the @{pairs} rule"
Map<String,String> hashData = new HashMap<>();
hashData.put("field1", "value1");
hashData.put("field2", "value2");
jdbc.executeUpdate("HSET myKey1 @{pairs, :arg0, :k :v}", SqlArg.valueOf(hashData));
```
- Reference: [HSET command](https://redis.io/docs/latest/commands/hset/), [PAIRS Rule](../../rules/dynamic_rule#pairs)

### List {#list}

```java title="Read/write list elements"
jdbc.executeUpdate("LPUSH myListKey value1 value2 value3");
String result = jdbc.queryForString("LPOP myListKey"); // value3
String result = jdbc.queryForString("RPOP myListKey"); // value1
```
- Reference: [LPUSH command](https://redis.io/docs/latest/commands/lpush/), [LPOP command](https://redis.io/docs/latest/commands/lpop/), [RPOP command](https://redis.io/docs/latest/commands/rpop/)

```java title="Implement message queue via LPUSH/BLPOP"
// Left-in right-out blocking queue
jdbc.executeUpdate("LPUSH myListKey value1");
String result = jdbc.queryForString("BRPOP myListKey");
// Right-in left-out blocking queue
jdbc.executeUpdate("RPUSH myListKey value1");
String result = jdbc.queryForString("BLPOP myListKey");
```
- Reference: [LPUSH command](https://redis.io/docs/latest/commands/lpush/), [BRPOP command](https://redis.io/docs/latest/commands/brpop/)

```java title="Persist a List to a list key using the @{pairs} rule"
List<String> listData = new ArrayList<>();
listData.add("value1");
listData.add("value2");
jdbc.executeUpdate("LPUSH myListKey @{pairs, :arg0, :v}", SqlArg.valueOf(listData));
```
- Reference: [LPUSH command](https://redis.io/docs/latest/commands/lpush/), [PAIRS Rule](../../rules/dynamic_rule#pairs)

### Set {#set}

```java title="Read/write set elements via SADD/SMEMBERS commands"
jdbc.executeUpdate("SADD mySetKey value1 value2 value3");
jdbc.queryForList("SMEMBERS mySetKey", String.class);
```
- Reference: [SADD command](https://redis.io/docs/latest/commands/sadd/), [SMEMBERS command](https://redis.io/docs/latest/commands/smembers/)

```java title="Tag articles by leveraging the uniqueness of SET keys"
jdbc.executeUpdate("SADD article_1 tag1 tag2");
jdbc.executeUpdate("SADD article_1 tag1 tag3");
jdbc.queryForList("SMEMBERS article_1", String.class); // Result: [tag1, tag2, tag3]
```

```java title="Persist Map keys to a Set using the @{pairs} rule"
Map<String,String> hashData = new HashMap<>();
hashData.put("field1", "value1");
hashData.put("field2", "value2");
jdbc.executeUpdate("SADD myKey1 @{pairs, :arg0, :k}", SqlArg.valueOf(hashData));
jdbc.queryForList("SMEMBERS myKey1", String.class); // Result: [field1, field2]
```
- Reference: [SADD command](https://redis.io/docs/latest/commands/sadd/), [PAIRS Rule](../../rules/dynamic_rule#pairs)

### Sorted Set {#sorted_set}

Sorted Set is similar to Set, but each element has a score, allowing elements to be sorted by score.

```java title="Read/write elements via ZADD/ZRANGEBYSCORE commands"
jdbc.execute("ZADD mySetKey 3 value3 2 value2 1 value1");
jdbc.queryForList("ZRANGEBYSCORE mySetKey -inf +inf ", String.class); // [value1, value2, value3]
```
- Reference: [ZADD command](https://redis.io/docs/latest/commands/zadd/), [ZRANGEBYSCORE command](https://redis.io/docs/latest/commands/zrangebyscore/)

```java title="Store elements with scores in a Map and persist to ZSet"
Map<String,Double> hashData = new HashMap<>();
hashData.put("field1", 3.0);
hashData.put("field2", 2.0);
hashData.put("field3", 1.0);
jdbc.executeUpdate("ZADD myKey1 @{pairs, :arg0, :v :k}", SqlArg.valueOf(hashData));
jdbc.queryForList("ZRANGEBYSCORE myKey1 -inf +inf ", String.class); // [field3, field2, field1]
```
- Reference: [ZADD command](https://redis.io/docs/latest/commands/zadd/), [PAIRS Rule](../../rules/dynamic_rule#pairs)

```java title="Persist scored data to ZSet using Tuple type and @{pairs} rule"
List<Tuple> data = new ArrayList<>();
data.add(Tuple.of("field1", 3.0));
data.add(Tuple.of("field2", 2.0));
data.add(Tuple.of("field3", 1.0));
jdbc.queryForString("ZADD myKey1 @{pairs, :arg0, :v.arg1 :v.arg0 }", SqlArg.valueOf(data));
jdbc.queryForList("ZRANGEBYSCORE myKey1 -inf +inf ", String.class); // [field3, field2, field1]
```
- Reference: [ZADD command](https://redis.io/docs/latest/commands/zadd/), [PAIRS Rule](../../rules/dynamic_rule#pairs)
- In addition to Tuple type, you can also use Map type or custom types to store elements and scores
  - `:v.arg1` uses the [Named Arguments](../../args/named) approach to pass parameters
