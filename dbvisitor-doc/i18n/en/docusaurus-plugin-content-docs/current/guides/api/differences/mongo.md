---
id: mongo
sidebar_position: 2
hide_table_of_contents: true
title: MongoDB Specifics
description: Capabilities and limitations of using dbVisitor with a MongoDB data source.
---

:::tip[Hint]
This article is generated by AI translation.
:::

# MongoDB Datasource Specifics

dbVisitor accesses MongoDB data sources via the [JDBC-Mongo](../../../drivers/mongo/about) driver, based on the JDBC protocol.

**Supported capabilities:**
- Execute MongoDB commands to manipulate data ([supported command list](../../../drivers/mongo/commands))
- [JdbcTemplate](#exec-command), [Fluent API](#exec-lambda), [BaseMapper](#exec-mapper), [Annotations](#exec-annotation), [Mapper File](#exec-file)
- Object Mapping, ResultSet Mapping, [Rules](../../rules/about), [Arguments](../../args/about), [ResultSetExtractor/RowMapper](../../result/about)
- [Dynamic SQL](../../core/file/dynamic) tags in Mapper Files, `Statement.RETURN_GENERATED_KEYS` (auto-retrieval of `_id`)

**Not supported:** executeBatch, stored procedures

## Concept Analogy

Different MongoDB commands produce three types of results:
- **Update count** — analogous to INSERT/UPDATE/DELETE, retrieved via `executeUpdate`
- **Single/multiple row results** — analogous to SELECT result sets; first column is `_ID`, second column is `_JSON` (both strings)

---

## Command Mode (JdbcTemplate) {#exec-command}

Use JdbcTemplate to execute MongoDB commands directly. Ensure you have properly configured the MongoDB data source first — see [MongoDB Driver Usage Guide](../../../drivers/mongo/usecase).

:::tip[Tip]
For more usage patterns, see [JdbcTemplate](../../core/jdbc/about#guide). The following features are not supported due to driver limitations:
- Batch operations
- Stored procedures
:::

```java title='Create JdbcTemplate'
JdbcTemplate jdbc = new JdbcTemplate(dataSource);
// or
JdbcTemplate jdbc = new JdbcTemplate(connection);
```

```java title='Insert data'
// Direct command
jdbc.execute("test.user_info.insert({name: 'mali', age: 26})");
// Parameterized command
jdbc.execute("test.user_info.insert(?)", new Object[] { "{name: 'mali', age: 26}" });
```

```java title='Query data'
// Query all
List<Map<String, Object>> list = jdbc.queryForList("test.user_info.find()");
// Conditional query
Map<String, Object> mali = jdbc.queryForMap("test.user_info.find({name: 'mali'})");
String json = (String) mali.get("_JSON");
```

```java title='Update data'
jdbc.execute("test.user_info.update({name: 'mali'}, {$set: {age: 27}})");
```

```java title='Delete data'
jdbc.execute("test.user_info.remove({name: 'mali'})");
```

---

## Fluent API (LambdaTemplate) {#exec-lambda}

The Fluent API provides a type-safe, chained approach for operating MongoDB. Usage is identical to RDBMS — see [Fluent API](../../core/lambda/about) for details.

```java title='Initialize'
LambdaTemplate lambda = new LambdaTemplate(dataSource);
```

```java title='Insert'
UserInfo user = new UserInfo();
user.setUid("1001");
user.setName("test_user");

int result = lambda.insert(UserInfo.class)
                   .applyEntity(user)
                   .executeSumResult();
```

```java title='Query'
// Query by condition
UserInfo user = lambda.query(UserInfo.class)
                      .eq(UserInfo::getUid, "1001")
                      .queryForObject();

// List query
List<UserInfo> users = lambda.query(UserInfo.class)
                             .like(UserInfo::getName, "test%")
                             .queryForList();
```

```java title='Update'
int result = lambda.update(UserInfo.class)
                   .eq(UserInfo::getUid, "1001")
                   .updateTo(UserInfo::getName, "New Name")
                   .doUpdate();
```

```java title='Delete'
int result = lambda.delete(UserInfo.class)
                   .eq(UserInfo::getUid, "1001")
                   .doDelete();
```

---

## BaseMapper Interface {#exec-mapper}

`BaseMapper` provides generic CRUD methods. Usage is identical to RDBMS — see [BaseMapper](../../core/mapper/about) for details.

```java title='Define Mapper interface'
@SimpleMapper
public interface UserInfoMapper extends BaseMapper<UserInfo> {
    // Custom methods can be added here
}
```

```java title='CRUD with Mapper'
Session session = ...;
UserInfoMapper mapper = session.createMapper(UserInfoMapper.class);

// Insert
mapper.insert(user);
// Query
UserInfo loadedUser = mapper.selectById(user.getUid());
// Update
loadedUser.setName("updated_name");
mapper.update(loadedUser);
// Delete
mapper.deleteById(user.getUid());
```

---

## Annotations {#exec-annotation}

:::tip[Tip]
All [annotations provided by the core API](../../core/annotation/about) work on MongoDB data sources, except for the `@Call` annotation.
:::

```java title='1. Define object'
@Table("user_info")
public class UserInfo {
    @Column(value = "uid", primary = true)
    private String uid;
    @Column("name")
    private String name;
    ... // getters/setters omitted
}
```

```java title='2. Define Mapper interface'
@SimpleMapper()
public interface UserInfoMapper {
    @Insert("test.user_info.insert(#{info, typeHandler=net.hasor.dbvisitor.types.handler.json.JsonTypeHandler})")
    int saveUser(@Param("info") UserInfo info);

    @Query("test.user_info.find({uid: #{uid}})")
    UserInfo loadUser(@Param("uid") String uid);

    @Delete("test.user_info.remove({uid: #{uid}})")
    int deleteUser(@Param("uid") String uid);
}
```

```java title='3. Create and use Mapper'
Configuration config = new Configuration();
Session session = config.newSession(dataSource);

UserInfoMapper mapper = session.createMapper(UserInfoMapper.class);
```

### ObjectId Mapping

MongoDB's `_id` field is typically of `ObjectId` type, while in Java objects we usually use `String`.

```java title='Define object (ObjectId mapping)'
@Table("user_info")
public class UserInfo {
    @Column(value = "_id", primary = true, keyType = KeyType.Auto, whereValueTemplate = "ObjectId(?)")
    private String id;

    @Column("name")
    private String name;
    ...
}
```

```java title='Mapper definition (query with ObjectId)'
@SimpleMapper()
public interface UserInfoMapper {
    @Query("test.user_info.find({_id: ObjectId(#{id})})")
    UserInfo loadById(@Param("id") String id);
}
```

### Paginated Query

Add a `Page` parameter to Mapper methods to enable paginated queries.

```java title='Mapper definition'
@SimpleMapper()
public interface UserInfoMapper {
    @Query("test.user_info.find({name: #{name}})")
    List<UserInfo> queryByName(@Param("name") String name, Page page);
}
```

```java title='Call with pagination'
Page page = new PageObject();
page.setPageSize(10);

List<UserInfo> list = mapper.queryByName("mali", page);
```

---

## File Mode (Mapper File) {#exec-file}

```java title='1. Define object'
@Table("user_info")
public class UserInfo {
    @Column(value = "uid", primary = true)
    private String uid;
    @Column("name")
    private String name;
    ... // getters/setters omitted
}
```

```xml title='2. Define Mapper file'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//dbvisitor.net//DTD Mapper 1.0//EN"
"https://www.dbvisitor.net/schema/dbvisitor-mapper.dtd">
<mapper namespace="net.test.dto.UserInfoMapper">
    <insert id="saveUser">
        test.user_info.insert(#{info, typeHandler=net.hasor.dbvisitor.types.handler.json.JsonTypeHandler})
    </insert>

    <select id="loadUser" resultType="net.test.dto.UserInfo">
        test.user_info.find({uid: #{uid}})
    </select>

    <delete id="deleteUser">
        test.user_info.remove({uid: #{uid}})
    </delete>
</mapper>
```

```java title='3. Define Mapper interface'
@RefMapper("/path/to/mapper.xml")
public interface UserInfoMapper {
    int saveUser(@Param("info") UserInfo info);

    UserInfo loadUser(@Param("uid") String uid);

    int deleteUser(@Param("uid") String uid);
}
```
