---
id: elastic
sidebar_position: 3
hide_table_of_contents: true
title: ElasticSearch Specifics
description: Capabilities and limitations of using dbVisitor with an ElasticSearch data source.
---

:::tip[Hint]
This article is generated by AI translation.
:::

# ElasticSearch Datasource Specifics

dbVisitor accesses ElasticSearch data sources via the [JDBC-Elastic](../../../drivers/elastic/about) driver, based on the JDBC protocol.

**Supported capabilities:**
- Execute ElasticSearch DSL commands to manipulate data ([supported command list](../../../drivers/elastic/commands))
- [JdbcTemplate](#exec-command), [Fluent API](#exec-lambda), [BaseMapper](#exec-mapper), [Annotations](#exec-annotation), [Mapper File](#exec-file)
- Object Mapping, ResultSet Mapping, [Rules](../../rules/about), [Arguments](../../args/about), [ResultSetExtractor/RowMapper](../../result/about)
- [Dynamic SQL](../../core/file/dynamic) tags in Mapper Files, `Statement.RETURN_GENERATED_KEYS` (auto-retrieval of `_id`)

**Not supported:** executeBatch, stored procedures

## Concept Analogy

Different ElasticSearch commands produce three types of results:
- **Update count** — analogous to INSERT/UPDATE/DELETE, retrieved via `executeUpdate`
- **Single/multiple row results** — analogous to SELECT result sets; first column is `_ID`, second column is `_DOC` (both strings)

---

## Command Mode (JdbcTemplate) {#exec-command}

Use JdbcTemplate to execute ElasticSearch commands directly. Ensure you have properly configured the ElasticSearch data source first — see [ElasticSearch Driver Usage Guide](../../../drivers/elastic/usecase).

:::tip[Tip]
For more usage patterns, see [JdbcTemplate](../../core/jdbc/about#guide). The following features are not supported due to driver limitations:
- Batch operations
- Stored procedures
:::

```java title='Create JdbcTemplate'
JdbcTemplate jdbc = new JdbcTemplate(dataSource);
// or
JdbcTemplate jdbc = new JdbcTemplate(connection);
```

```java title='Insert data'
// Direct command
jdbc.execute("POST /my_index/_doc/1 { \"name\": \"mali\", \"age\": 26 }");
// Parameterized command
jdbc.execute("POST /my_index/_doc/1 { \"name\": ?, \"age\": ? }", new Object[] { "mali", 26 });
```

```java title='Query data'
// Query all
List<Map<String, Object>> list = jdbc.queryForList(
    "POST /my_index/_search { \"query\": { \"match_all\": {} } }");
// Conditional query
Map<String, Object> mali = jdbc.queryForMap(
    "POST /my_index/_search { \"query\": { \"term\": { \"name\": \"mali\" } } }");
String json = (String) mali.get("_DOC");
```

```java title='Update data'
jdbc.execute("POST /my_index/_update/1 { \"doc\": { \"age\": 27 } }");
```

```java title='Delete data'
jdbc.execute("DELETE /my_index/_doc/1");
```

---

## Fluent API (LambdaTemplate) {#exec-lambda}

The Fluent API provides a type-safe, chained approach for operating ElasticSearch. Usage is identical to RDBMS — see [Fluent API](../../core/lambda/about) for details.

```java title='Initialize'
LambdaTemplate lambda = new LambdaTemplate(dataSource);
```

```java title='Insert'
UserInfo user = new UserInfo();
user.setUid("1001");
user.setName("test_user");

int result = lambda.insert(UserInfo.class)
                   .applyEntity(user)
                   .executeSumResult();
```

```java title='Query'
UserInfo user = lambda.query(UserInfo.class)
                      .eq(UserInfo::getUid, "1001")
                      .queryForObject();

List<UserInfo> users = lambda.query(UserInfo.class)
                             .like(UserInfo::getName, "test%")
                             .queryForList();
```

```java title='Update'
int result = lambda.update(UserInfo.class)
                   .eq(UserInfo::getUid, "1001")
                   .updateTo(UserInfo::getName, "New Name")
                   .doUpdate();
```

```java title='Delete'
int result = lambda.delete(UserInfo.class)
                   .eq(UserInfo::getUid, "1001")
                   .doDelete();
```

---

## BaseMapper Interface {#exec-mapper}

`BaseMapper` provides generic CRUD methods. Usage is identical to RDBMS — see [BaseMapper](../../core/mapper/about) for details.

```java title='Define Mapper interface'
@SimpleMapper
public interface UserInfoMapper extends BaseMapper<UserInfo> {
    // Custom methods can be added here
}
```

```java title='CRUD with Mapper'
Session session = ...;
UserInfoMapper mapper = session.createMapper(UserInfoMapper.class);

// Insert
mapper.insert(user);
// Query
UserInfo loadedUser = mapper.selectById(user.getUid());
// Update
loadedUser.setName("updated_name");
mapper.update(loadedUser);
// Delete
mapper.deleteById(user.getUid());
```

---

## Annotations {#exec-annotation}

:::tip[Tip]
All [annotations provided by the core API](../../core/annotation/about) work on ElasticSearch data sources, except for the `@Call` annotation.
:::

```java title='1. Define object'
@Table("user_info")
public class UserInfo {
    @Column(value = "uid", primary = true)
    private String uid;
    @Column("name")
    private String name;
    ... // getters/setters omitted
}
```

```java title='2. Define Mapper interface'
@SimpleMapper()
public interface UserInfoMapper {
    @Insert("POST /user_info/_doc { \"uid\": #{info.uid}, \"name\": #{info.name} }")
    int saveUser(@Param("info") UserInfo info);

    @Query("POST /user_info/_search { \"query\": { \"term\": { \"uid\": #{uid} } } }")
    UserInfo loadUser(@Param("uid") String uid);

    @Delete("POST /user_info/_delete_by_query { \"query\": { \"term\": { \"uid\": #{uid} } } }")
    int deleteUser(@Param("uid") String uid);
}
```

```java title='3. Create and use Mapper'
Configuration config = new Configuration();
Session session = config.newSession(dataSource);

UserInfoMapper mapper = session.createMapper(UserInfoMapper.class);
```

### Paginated Query

Add a `Page` parameter to Mapper methods to enable paginated queries.

```java title='Mapper definition'
@SimpleMapper()
public interface UserInfoMapper {
    @Query("POST /user_info/_search { \"query\": { \"match_all\": {} } }")
    List<UserInfo> queryAll(Page page);
}
```

```java title='Call with pagination'
Page page = new PageObject();
page.setPageSize(10);

List<UserInfo> list = mapper.queryAll(page);
```

---

## File Mode (Mapper File) {#exec-file}

```java title='1. Define object'
@Table("user_info")
public class UserInfo {
    @Column(value = "uid", primary = true)
    private String uid;
    @Column("name")
    private String name;
    ... // getters/setters omitted
}
```

```xml title='2. Define Mapper file'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//dbvisitor.net//DTD Mapper 1.0//EN"
"https://www.dbvisitor.net/schema/dbvisitor-mapper.dtd">
<mapper namespace="net.test.dto.UserInfoMapper">
    <insert id="saveUser">
        POST /user_info/_doc {
            "uid": #{info.uid},
            "name": #{info.name}
        }
    </insert>

    <select id="loadUser" resultType="net.test.dto.UserInfo">
        POST /user_info/_search {
            "query": {
                "term": { "uid": #{uid} }
            }
        }
    </select>

    <delete id="deleteUser">
        POST /user_info/_delete_by_query {
            "query": {
                "term": { "uid": #{uid} }
            }
        }
    </delete>
</mapper>
```

```java title='3. Define Mapper interface'
@RefMapper("/path/to/mapper.xml")
public interface UserInfoMapper {
    int saveUser(@Param("info") UserInfo info);

    UserInfo loadUser(@Param("uid") String uid);

    int deleteUser(@Param("uid") String uid);
}
```
