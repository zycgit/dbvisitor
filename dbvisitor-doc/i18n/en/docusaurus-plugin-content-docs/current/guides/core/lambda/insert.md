---
id: insert
sidebar_position: 1
hide_table_of_contents: true
title: Insert
description: Insert data with dbVisitor constructors using either entity beans or Maps as containers.
---
:::tip[Hint]
This article is generated by AI translation.
:::

# Insert

You can insert data using an entity bean or a `Map` as the container.

```java title='Use a bean as the data container'
User user = new User();
user.setId(20);
user.setName("new name");
user.setAge(88);
user.setCreateTime(new Date());

LambdaTemplate lambda = ...;
int result = lambda.insert(User.class)
                   .applyEntity(user)
                   .executeSumResult();
// result is 1
```

```java title='Use a Map as the data container'
Map<String, Object> user = new HashMap<>();
user.put("id", 20);
user.put("name", "new name");
user.put("age", 88);
user.put("create_time", new Date());

LambdaTemplate lambda = ...;
int result = lambda.insert(User.class)
                   .applyMap(user)
                   .executeSumResult();
// result is 1
```

## Batching {#batch}

Use batch insert when inserting many records.

```java
User user1 = new User();
...
User user2 = new User();
...
User user3 = new User();
...

LambdaTemplate lambda = ...
int result = lambda.insert(User.class)
                   .applyEntity(user1, user2, user3);               // varargs
                 //.applyEntity(new User[]{user1, user2, user3});  // array
                 //.applyEntity(Arrays.asList(user1, user2, user3));// List
                   .executeSumResult();
// result is 3
```

- For Map data, use `applyMap` instead of `applyEntity`.
- You can call `applyEntity`/`applyMap` multiple times before `executeSumResult` to stage batches.

## Write conflicts {#conflict}

Unintentionally inserting duplicates can cause primary-key conflicts. A common approach is “check then update/insert,” e.g.:

```java title='Common approach'
if (adapter.queryByEntity(User.class)
            .eq(User::getId,user.getId())
            .queryForCount() > 0) {
  // update
} else {
  // insert
}
```

Databases often provide more efficient conflict handling, for example:

- MySQL: `ON DUPLICATE KEY UPDATE` on INSERT.
- Oracle: `MERGE INTO ... WHEN MATCHED THEN ... WHEN NOT MATCHED THEN ...`.

Using these dialect features requires:
- dbVisitor dialect support; see [dialect support](../../api/differences/about#dialect).
- Setting a conflict strategy via `onDuplicateStrategy`.

dbVisitor provides three conflict strategies to avoid extra code:
- Into: plain `INSERT INTO` (throws on conflict).
- Update: use dialect-specific MERGE/ON CONFLICT to update on conflict.
- Ignore: use IGNORE or dialect-specific syntax to skip conflicting rows.

### Default (INTO)

Uses plain `insert into`; conflicts error out.

```java title='Default strategy can be omitted or explicitly set'
LambdaTemplate lambda = ...
int result = lambda.insert(User.class)
                   .applyEntity(user)
                   .onDuplicateStrategy(DuplicateKeyStrategy.Into) // explicit
                   .executeSumResult();
```

### Replace (UPDATE)

Implementation depends on dialect, for example:

- MySQL: `ON DUPLICATE KEY UPDATE` clause on INSERT.
- Oracle: `MERGE INTO ... WHEN MATCHED THEN ... WHEN NOT MATCHED THEN ...`.
- PostgreSQL: `ON CONFLICT (...) DO UPDATE SET ...`.

:::info[Tip]
Dialect determines availability; forcing it without support will raise errors.
:::

```java title='Usage'
LambdaTemplate lambda = ...
int result = lambda.insert(User.class)
                   .applyEntity(user)
                   .onDuplicateStrategy(DuplicateKeyStrategy.Update) // update on conflict
                   .executeSumResult();
```

### Ignore (IGNORE)

Implementation depends on dialect, for example:

- MySQL: `INSERT IGNORE`.
- Oracle: `MERGE INTO ... WHEN NOT MATCHED THEN ...`.
- DM: hint `IGNORE_ROW_ON_DUPKEY_INDEX` to ignore by PK.

```java title='Usage'
LambdaTemplate lambda = ...
int result = lambda.insert(User.class)
                   .applyEntity(user)
                   .onDuplicateStrategy(DuplicateKeyStrategy.Ignore) // ignore on conflict
                   .executeSumResult();
```
