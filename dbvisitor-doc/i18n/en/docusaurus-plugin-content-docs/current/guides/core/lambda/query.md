---
id: query
sidebar_position: 4
hide_table_of_contents: true
title: Query
description: Use LambdaTemplate to query data and fetch results in multiple ways.
---
:::tip[Hint]
This article is generated by AI translation.
:::

# Query

LambdaTemplate supports multiple result forms:
- [List](./query#list): map results to a list of objects.
- [Object](./query#object): map a single result.
- [Count](./query#count): rewrite the query to COUNT using dialect support.
- [Streaming](./query#process): handle results via `RowCallbackHandler` or `ResultSetExtractor`.
- [Pagination](./query#page): paginate queries.

:::info[Tip]
For building conditions used in queries, see **[where builder](./where-builder)**.
:::

## Query list {#list}

Run a query and map results to a list.

```java title='Map to entity type'
LambdaTemplate lambda = ...;

List<User> result = null;
result = lambda.query(User.class)
               .le(User::getId, 100)   // match id <= 100
               .queryForList();        // map to entity type
```

```java title='Map to a specific type'
LambdaTemplate lambda = ...;

List<UserVO> result = null;
result = lambda.query(User.class)
               .le(User::getId, 100)        // match id <= 100
               .queryForList(UserVO.class); // map to target type
```

- When mapping `User` results to another type, mapping follows the target type’s rules. See [Object Mapping](../mapping/about) for details.

```java title='Map to Map'
LambdaTemplate lambda = ...;

List<Map<String,Object>> result = null;
result = lambda.query(User.class)
               .le(User::getId, 100)    // match id <= 100
               .queryForMapList();      // map to Map
```

- Map keys correspond to `User` property names.

```java
LambdaTemplate lambda = ...;
RowMapper<UserVO> rowMapper = new BeanMappingRowMapper(UserVO.class);

List<UserVO> result = null;
result = lambda.query(User.class)
               .le(User::getId, 100)    // match id <= 100
               .queryForList(rowMapper);// use RowMapper for mapping
```

- Use [RowMapper](../../result/for_mapper) to customize row mapping from `ResultSet`.

## Query a single object {#object}

Run a query and map the single result; multiple matches throw an exception.

```java title='Map to entity type'
LambdaTemplate lambda = ...;

User result = null;
result = lambda.query(User.class)
               .eq(User::getId, 100)   // match id = 100
               .queryForObject();      // map to entity type
```

```java title='Map to a specific type'
LambdaTemplate lambda = ...;

UserVO result = null;
result = lambda.query(User.class)
               .eq(User::getId, 100)          // match id = 100
               .queryForObject(UserVO.class); // map to target type
```

- When mapping `User` results to another type, mapping follows the target type’s rules. See [Object Mapping](../mapping/about) for details.

```java title='Map to Map'
LambdaTemplate lambda = ...;

Map<String,Object> result = null;
result = lambda.query(User.class)
               .eq(User::getId, 100) // match id = 100
               .queryForMap();       // map to Map
```

- Map keys correspond to `User` property names.

```java
LambdaTemplate lambda = ...;
RowMapper<UserVO> rowMapper = new BeanMappingRowMapper(UserVO.class);

List<UserVO> result = null;
result = lambda.query(User.class)
               .le(User::getId, 100)     // match id <= 100
               .queryForObject(rowMapper);// use RowMapper for mapping
```

- Use [RowMapper](../../result/for_mapper) to customize row mapping from `ResultSet`.

## Count {#count}

dbVisitor rewrites the query into a COUNT using dialect support. Example:

```sql
-- original query
select id, name from users where id <= 100;
-- rewritten as count query
select count(*) from (select id, name from users where id <= 100;) as TEMP_T;
```

```java
LambdaTemplate lambda = ...;
RowMapper<UserVO> rowMapper = new BeanMappingRowMapper(UserVO.class);

int count = lambda.query(User.class)
                  .le(User::getId, 100)  // match id <= 100
                  .queryForCount();      // count as int
                //.queryForLargeCount(); // count as long
```

- Choose `queryForCount` or `queryForLargeCount` based on size needs.

## Streaming {#process}

Use [RowCallbackHandler](../../result/row_callback) to process each row without collecting the result set.

```java
RowCallbackHandler handler = new RowCallbackHandler() {
    @Override
    public void processRow(ResultSet rs, int rowNum) throws SQLException {
        ...
    }
};

LambdaTemplate lambda = ...;

lambda.query(User.class)
      .eq(User::getId, 100)  // match id = 100
      .query(handler);       // process via RowCallbackHandler
```

Use [ResultSetExtractor](../../result/for_extractor) to process the entire `ResultSet`.

```java
ResultSetExtractor extractor = new ResultSetExtractor<Map<Integer, String>>() {
    public Map<Integer, String> extractData(ResultSet rs) throws SQLException {
        Map<Integer, String> hashMap = new HashMap<>();

        while (rs.next()) {
            int id = rs.getInt("id");
            String name = rs.getString("name");
            hashMap.put(id, name);
        }

        return hashMap;
    }
};

LambdaTemplate lambda = ...;

Map<Integer, String> result = null;
result = lambda.query(User.class)
               .eq(User::getId, 100)  // match id = 100
               .query(extractor);     // process via ResultSetExtractor
```

## Pagination {#page}

:::info[Tip]
Pagination depends on dialect support; see **[database support](../../api/differences/about#dialect)** for supported databases.
:::

dbVisitor provides built-in pagination with no extra config. Usage:

```java title='Using page arguments'
LambdaTemplate lambda = ...;

List<User> result = null;
result = lambda.query(User.class)
               .le(User::getId, 100) // match id <= 100
               .initPage(10, 1)      // page size 10, fetch page 2 (0-based)
               .queryForList();      // paged query
```

```java title='Using a Page object'
LambdaTemplate lambda = ...;

// Page object
Page page = new PageObject();
page.setPageNumberOffset(1); // start page numbering at 1
page.setPageSize(10);        // 10 rows per page
page.setCurrentPage(2);      // fetch page 2

// paged query
List<User> result = null;
result = lambda.query(User.class)
               .le(User::getId, 100) // match id <= 100
               .usePage(page)        // pagination info
               .queryForList();      // paged query
```

- The Pagination Object provides many useful methods. See [Pagination Object](../../api/page_object) for more details.
- The [query list](./query#list) and [result processing](./query#process) methods mentioned above can be combined with pagination.

