---
id: query
sidebar_position: 2
title: Queries
description: Execute SQL with results and work with the returned data.
---
:::tip[Hint]
This article is generated by AI translation.
:::

import TagRed from '@site/src/components/tags/TagRed';
import TagGray from '@site/src/components/tags/TagGray';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Queries

JdbcTemplate offers several read-only APIs. Most take an SQL string plus arguments (object or array) and return objects built from the result set; some provide callbacks/mappers for custom processing.

## Query Result Sets {#list}

Query a collection of objects or maps and return them.

<Tabs>
    <TabItem value="demo1" label="ObjectMapping">

        ```java
        // Raw SQL
        List<User> users = jdbc.queryForList(
                "select * from users where id > 2", User.class);

        // Positional arguments
        Object[] args = new Object[]{ 2 };
        List<User> result = jdbc.queryForList(
                "select * from users where id > ?", args, User.class);

        // Named arguments
        Map<String, Object> args = CollectionUtils.asMap("id", 2);
        List<User> result = jdbc.queryForList(
                "select * from users where id > :id", args, User.class);
        ```

    </TabItem>
    <TabItem value="demo2" label="Map">

        ```java
        // Raw SQL
        List<Map<String, Object>> users = jdbc.queryForList(
                "select * from users where id > 2");

        // Positional arguments
        Object[] args = new Object[]{ 2 };
        List<Map<String, Object>> result = jdbc.queryForList(
                "select * from users where id > ?", args);

        // Named arguments
        Map<String, Object> args = CollectionUtils.asMap("id", 2);
        List<Map<String, Object>> result = jdbc.queryForList(
                "select * from users where id > :id", args);
        ```

    </TabItem>
    <TabItem value="sig" label="Signatures">

        ```java
        // Object mapping or type handler
        List<T> queryForList(String sql, Class<T> elementType);
        List<T> queryForList(String sql, Object args, Class<T> elementType);
        List<T> queryForList(String sql, PreparedStatementSetter pss, Class<T> elementType);

        // RowMapper
        List<T> queryForList(String sql, RowMapper<T> rowMapper);
        List<T> queryForList(String sql, Object args, RowMapper<T> rowMapper);
        List<T> queryForList(String sql, PreparedStatementSetter pss, RowMapper<T> rowMapper);

        // Receive as List/Map without mapping
        List<Map<String, Object>> queryForList(String sql);
        List<Map<String, Object>> queryForList(String sql, Object args);
        List<Map<String, Object>> queryForList(String sql, PreparedStatementSetter pss);
        ```

    </TabItem>
</Tabs>

## Query a Single Object {#one}

Return one row mapped to the specified type. Common use: aggregates or primary-key lookups. Multiple rows will raise an exception.

<Tabs>
    <TabItem value="demo1" label="ObjectMapping">

        ```java
        // Raw SQL
        User user = jdbc.queryForObject(
                "select * from users where id = 2", User.class);

        // Positional arguments
        Object[] args = new Object[]{ 2 };
        User user = jdbc.queryForObject(
                "select * from users where id = ?", args, User.class);

        // Named arguments
        Map<String, Object> args = CollectionUtils.asMap("id", 2);
        User user = jdbc.queryForObject(
                "select * from users where id = :id", args, User.class);
        ```

    </TabItem>
    <TabItem value="demo2" label="Map">

        ```java
        // Raw SQL
        Map<String, Object> user = jdbc.queryForMap(
                "select * from users where id = 2");

        // Positional arguments
        Object[] args = new Object[]{ 2 };
        Map<String, Object> user = jdbc.queryForMap(
                "select * from users where id = ?", args);

        // Named arguments
        Map<String, Object> args = CollectionUtils.asMap("id", 2);
        Map<String, Object> user = jdbc.queryForMap(
                "select * from users where id = :id", args);
        ```

    </TabItem>
    <TabItem value="sig" label="Signatures">

        ```java
        // Object Mapping or Type Handler
        T queryForObject(String sql, Class<T> requiredType);
        T queryForObject(String sql, Object args, Class<T> requiredType);
        T queryForObject(String sql, PreparedStatementSetter pss, Class<T> requiredType);

        // RowMapper
        T queryForObject(String sql, RowMapper<T> rowMapper);
        T queryForObject(String sql, Object args, RowMapper<T> rowMapper);
        T queryForObject(String sql, PreparedStatementSetter pss, RowMapper<T> rowMapper);

        // Receive as List/Map without mapping
        Map<String, Object> queryForMap(String sql);
        Map<String, Object> queryForMap(String sql, Object args);
        Map<String, Object> queryForMap(String sql, PreparedStatementSetter pss);
        ```

    </TabItem>
</Tabs>

## Query Key-Value Pairs {#pairs}

Use the first and second columns of the result set as Map key/value.

<Tabs>
    <TabItem value="demo" label="Example">

        ```java
        // Raw SQL
        Map<Long, String> userMap = jdbc.queryForPairs(
                "select uid, name from user where age > 2", Long.class, String.class);

        // Positional arguments
        Object[] args = new Object[]{ 2 };
        Map<Long, String> userMap = jdbc.queryForPairs(
                "select uid, name from user where age > ?", Long.class, String.class, args);

        // Named arguments
        Map<String, Object> args = CollectionUtils.asMap("age", 2);
        Map<Long, String> userMap = jdbc.queryForPairs(
                "select uid, name from user where age > :age", Long.class, String.class, args);
        ```

    </TabItem>
    <TabItem value="sig" label="Signatures">

        ```java
        // pairKey and pairValue are mapped via object mapping or type handlers
        Map<K, V> queryForPairs(String sql,
                    Class<K> pairKey, Class<V> pairValue);
        Map<K, V> queryForPairs(String sql,
                    Class<K> pairKey, Class<V> pairValue, Object args);
        Map<K, V> queryForPairs(String sql,
                    Class<K> pairKey, Class<V> pairValue, PreparedStatementSetter args);
        ```

    </TabItem>
</Tabs>

## Query Values {#value}

Values are the smallest mappable units (types registered in [TypeHandlerRegistry](../../types/handlers/about)), e.g., `String`, `Int`, `Date`. Two common cases:
- Value lists, e.g., an ID collection.
- Aggregate info, e.g., counts or averages.

<Tabs>
    <TabItem value="demo1" label="Single value">

        ```java
        // Raw SQL
        long count = jdbc.queryForLong(
                "select count(*) from user where age > 2");

        // Positional arguments
        Object[] args = new Object[]{ 2 };
        long count = jdbc.queryForLong(
                "select count(*) from user where age > ?", args);

        // Named arguments
        Map<String, Object> args = CollectionUtils.asMap("age", 2);
        long count = jdbc.queryForLong(
                "select count(*) from user where age > :age", args);
        ```

        :::info[Hint]
        - `jdbc.queryForObject("select count(*) from users", Integer.class);` is equivalent.
        :::

    </TabItem>
    <TabItem value="demo2" label="Multiple value">

        ```java
        // Raw SQL
        List<String> result = jdbc.queryForList(
                "select name from users", String.class);

        // Positional arguments
        Object[] args = new Object[]{ 2 };
        List<String> result = jdbc.queryForList(
                "select name from users where name = ?", args, String.class);

        // Named arguments
        Map<String, Object> args = CollectionUtils.asMap("name", "Bob");
        List<String> result = jdbc.queryForList(
                "select name from users where id = :id", args, String.class);
        ```

    </TabItem>
    <TabItem value="sig" label="Signatures">

        ```java
        // Query Long
        Long queryForLong(String sql);
        Long queryForLong(String sql, Object args);
        Long queryForLong(String sql, PreparedStatementSetter args)

        // Query int
        Integer queryForInt(String sql);
        Integer queryForInt(String sql, Object args);
        Integer queryForInt(String sql, PreparedStatementSetter args);

        // Query String
        String queryForString(String sql);
        String queryForString(String sql, Object args);
        String queryForString(String sql, PreparedStatementSetter args);
        ```

    </TabItem>
</Tabs>

## Use ResultSetExtractor {#extractor}

Using the `ResultSetExtractor` interface is the most flexible way to handle result sets. Users need to implement the actual work of extracting results from the ResultSet themselves, without worrying about exception handling.

<Tabs>
    <TabItem value="demo1" label="Example">

        ```java
        // Custom result extraction using ResultSetExtractor
        User user = jdbc.query(
            "select * from users where id = ?",
            new Object[]{ 1 },
            (ResultSetExtractor<User>) rs -> {
                if (rs.next()) {
                    User u = new User();
                    u.setId(rs.getLong("id"));
                    u.setName(rs.getString("name"));
                    return u;
                }
                return null;
            }
        );
        ```

    </TabItem>
    <TabItem value="sig" label="Signatures">

        ```java
        // Use ResultSetExtractor
        T query(String sql, ResultSetExtractor<T> rse);
        T query(String sql, Object args, ResultSetExtractor<T> rse);
        T query(String sql, PreparedStatementSetter args, ResultSetExtractor<T> rse);
        ```

    </TabItem>
</Tabs>

## Streaming Queries {#stream}

For very large result sets, stream rows to save memory; each row is handled immediately in the callback.

<Tabs>
    <TabItem value="demo1" label="Example">

        ```java
        // Stream rows
        RowCallbackHandler handler = (rs, rowNum) -> {
            // handle one row
        };

        // Raw SQL
        jdbc.query("select * from user where age > 2", handler);

        // Positional arguments
        Object[] args = new Object[]{ 2 };
        jdbc.query("select * from user where age > ?", args, handler);

        // Named arguments
        Map<String, Object> args = CollectionUtils.asMap("age", 2);
        jdbc.query("select * from user where age > :age", args, handler);
        ```

    </TabItem>
    <TabItem value="sig" label="Signatures">

        ```java
        void query(String sql, RowCallbackHandler rch);
        void query(String sql, Object args, RowCallbackHandler rch);
        void query(String sql, PreparedStatementSetter args, RowCallbackHandler rch);
        ```

    </TabItem>
</Tabs>

## Map Case Sensitivity {#case}

When storing results in `Map`, keys are case-insensitive by default.

```java title='Example query'
List<Map<String, Object>> result = jdbc.queryForList("select * from users");
```

Running the same table/data on different databases can yield different column name casing:
- Oracle defaults to uppercase column names.
- MySQL defaults to lowercase column names.

dbVisitor uses `LinkedCaseInsensitiveMap` by default to store column names case-insensitively (`resultsCaseInsensitive` defaults to true).
- If you want case-sensitive storage, set it to false.

```java
JdbcTemplate jdbc = ...
jdbc.setResultsCaseInsensitive(false);

List<Map<String, Object>> result = jdbc.queryForList("select * from users");
```

With `jdbc.setResultsCaseInsensitive(false)`, column names become case-sensitive and `LinkedHashMap` is used.
- Default `true` means column names are case-insensitive.
- `false` preserves case strictly.

## Result Handlers {#result}

- [ResultSetExtractor](../../result/for_extractor): use the ResultSetExtractor interface to customize ResultSet processing.
- [RowMapper](../../result/for_mapper): the benefit of using RowMapper is that you don't need to worry about ResultSet processing; just focus on processing each individual row.
- [RowCallbackHandler](../../result/row_callback): typically used for streaming large-scale data. Data does not remain in memory during processing.
- [TypeHandler](../../types/about): associate a TypeHandler via the `@BindTypeHandler` annotation to handle field serialization/deserialization in single-row-single-column or single-column-multi-row queries.

## Query Argument Notes {#arguments}

In query-related APIs, arguments are passed uniformly as `Object`. Supported types include:

- [Positional arguments](../../args/position) (equivalent to `Object... args`)
    - Arrays, Collection, types registered in TypeRegistry
- [Named arguments](../../args/named)
    - Map, entity Bean, SqlArg (name will be fixed as `arg0`)
- Custom: fully custom argument-setting logic for scenarios requiring manual type control.
    - [PreparedStatementSetter](../../args/interface#pset), [SqlArgSource](../../args/interface#source)
- Dynamic SQL
    - Use [Rules](../../rules/dynamic_rule) to bind arguments when building query commands, supporting named arguments.
    - Using `${...}` for [SQL injection](../../args/inject) does not participate in PreparedStatement but is still a form of argument passing.


Argument types are ultimately processed through TypeHandler to ensure correct mapping between JDBC types and Java types.
