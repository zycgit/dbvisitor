---
id: about
sidebar_position: 1
hide_table_of_contents: true
title: Rules
description: Use @{...} inside SQL to invoke rules that greatly reduce the work and complexity of dynamic command assembly.
---
:::tip[Hint]
This article is generated by AI translation.
:::

You can invoke rules in SQL with `@{...}`. Rules significantly reduce the effort and complexity of assembling dynamic command.

```text title='Rule syntax'
@{<ruleName> [, <enableCondition OGNL> [, ruleContent ]])
```

:::info
Rules cannot be nested.
:::

## Guide

dbVisitor ships many useful rules, grouped by purpose:

- [Argument rules](./args_rule): define or process data, e.g., MD5 hashing, UUID generation, encryption/decryption.
- [Result rules](./result_rule): process data in result sets, e.g., encryption/decryption, replace, mask.
- [Dynamic_rules](./dynamic_rule): simple dynamic command, e.g., only include a param when not null.
- [Macro rules](./macro_rule): alter the final command sent to the DB, e.g., argument-driven ordering, computed sharded table names.
- [Assist rules](./assist_rule): no direct query/result effect; used in specific scenarios such as stored procedure helpers.

## Basics

Some rules are invoked by name, for example:

```sql title='Generate a 32-character UUID as an argument'
update users set str_id = @{uuid32} where id = :id
```

When a rule should apply only under a condition:

```sql title='Append name = :name only when queryType is NAME'
select * from users where status = 1 @{ifand, queryType == 'NAME', name = :name}
```

To ignore the enable condition and apply it directly:

```sql title='Option 1: leave the condition empty'
select * from users where status = 1 @{ifand, , name = :name}
```

```sql title='Option 2: set the condition to true'
select * from users where status = 1 @{ifand, true, name = :name}
```
