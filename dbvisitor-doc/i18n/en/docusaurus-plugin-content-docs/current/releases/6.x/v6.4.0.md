---
id: v6.4.0
sidebar_position: 989
title: v6.4.0 (2026-01-05)
---

# v6.4.0 (2026-01-05)

```xml
<dependency>
    <groupId>net.hasor</groupId>
    <artifactId>dbvisitor</artifactId>
    <version>6.4.0</version>
</dependency>
<dependency>
    <groupId>net.hasor</groupId>
    <artifactId>jdbc-elastic</artifactId>
    <version>6.4.0</version>
</dependency>
```

## Impact Scope

- Added [jdbc-elastic driver](../../guides/drivers/elastic/usecase) and Es6Dialect, Es7Dialect
- dbvisitor-driver connection management mechanism
- jdbc-mongo driver stability
- TypeHandlerRegistry type matching logic

## Updates

- Added
  - Added `jdbc-elastic` driver, supporting standard JDBC interface to operate ElasticSearch using QueryDSL.
  - `jdbc-elastic` supports native REST API style commands (GET/POST/PUT/DELETE) and SQL Hint syntax.
  - `jdbc-elastic` supports `PreparedStatement` placeholder `?`, and `Statement.RETURN_GENERATED_KEYS` to automatically return `_id`.
  - `jdbc-elastic` supports `LambdaTemplate` and Mapper interfaces, providing type-safe CRUD operations.
  - `jdbc-elastic` supports Pre-read mode to effectively handle large result sets and avoid OutOfMemory errors.
  - `SqlDialectRegister` supports selecting finer-grained dialect implementations based on the database version provided by the driver.
  - `jdbc-elastic` supports the `indexRefresh` parameter to automatically refresh the index after write operations.
- Improved
  - Optimized the matching logic for abstract types in `TypeHandlerRegistry` to improve the accuracy of type handler lookup.
  - Optimized error handling logic for MongoDB and Redis when executing multiple statements, ensuring that a failure in a single statement correctly interrupts subsequent execution.
  - Unified the use of `ObjectMapper` objects in the project to reduce resource consumption.
- Fixed
  - Fixed an issue where `JdbcConnection` did not trigger `AdapterConnection` close when closing, leading to connection leaks.
  - Fixed a potential file handle leak issue in `MongoResultBuffer`.
  - Fixed an issue where MongoDB could not automatically discover the dialect when creating a Mapper via Session.
  - Fixed an issue where the `AdapterContainer` state was not reset after `executeUpdate` failed, causing subsequent queries to report errors.
  - Fixed response processing logic defects in `MongoConn` and `JedisConn`.

## How to use ElasticSearch?

```java title='Using JdbcTemplate to execute commands'
// 1. Get ElasticSearch Connection
Connection esConn = ...; // Refer to docs: Driver Adapter > JDBC Elastic > Installation & Configuration
JdbcTemplate jdbc = new JdbcTemplate(esConn);

// 2. Insert data
jdbc.execute("POST /my_index/_doc/1 { \"name\": \"mali\", \"age\": 26 }");

// 3. Query data
List<Map<String, Object>> list = jdbc.queryForList(
    "POST /my_index/_search { \"query\": { \"match_all\": {} } }");

// 4. Update data
jdbc.execute("POST /my_index/_update/1 { \"doc\": { \"age\": 27 } }");

// 5. Delete data
jdbc.execute("DELETE /my_index/_doc/1");
```

```java title='Using Mapper Interface'
// 1. Define Entity
@Table("my_index")
public class UserInfo {
    @Column(value = "uid", primary = true)
    private String uid;
    @Column("name")
    private String name;
    // getters and setters
}

// 2. Define Mapper Interface
@SimpleMapper
public interface UserInfoMapper extends BaseMapper<UserInfo> {
    @Insert("POST /my_index/_doc { \"uid\": #{user.uid}, \"name\": #{user.name} }")
    int saveUser(@Param("user") UserInfo user);

    @Query("POST /my_index/_search { \"query\": { \"term\": { \"uid\": #{uid} } } }")
    UserInfo loadUser(@Param("uid") String uid);
}

// 3. Use Mapper
try (Session session = config.newSession(esConn)) {
    UserInfoMapper mapper = session.createMapper(UserInfoMapper.class);

    // Save
    UserInfo user = new UserInfo();
    user.setUid("1111");
    user.setName("mali");
    mapper.saveUser(user);

    // Query
    UserInfo loaded = mapper.loadUser("1111");
}
```

```java title='Using LambdaTemplate'
// 1. Get ElasticSearch Connection
LambdaTemplate lambda = new LambdaTemplate(esConn);

// 2. Insert data
UserInfo user = new UserInfo();
user.setUid("1001");
user.setName("test_user");
lambda.insert(user);

// 3. Query data
UserInfo loaded = lambda.query(UserInfo.class)
                        .eq(UserInfo::getUid, "1001")
                        .queryForObject();
```

## Related Reading
- [Coding ElasticSearch with Joy (MyBatis Style)](../../../blog/elasticsearch-mybatis-style)
- [dbVisitor Next Generation Data Access Layer](../../../blog/new-generation-dbvisitor)
- [Elastic Driver Documentation](../../guides/drivers/elastic/about)

