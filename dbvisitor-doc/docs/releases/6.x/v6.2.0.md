---
id: v6.2.0
sidebar_position: 992
title: v6.2.0 (2025-11-12)
---

# v6.2.0 (2025-11-12)

```xml
<dependency>
    <groupId>net.hasor</groupId>
    <artifactId>jdbc-redis</artifactId>
    <version>6.2.0</version>
</dependency>
```

## 影响范围

- dbvisitor-driver 项目
- [jdbc-redis 驱动](../../guides/drivers/redis/usecase)

## 更新内容

- [新增] 在 [Mapper 注解化](../../guides/core/annotation/about)、[Mapper File](../../guides/core/file/about)、[JdbcTemplate](../../guides/core/jdbc/about) 级别 API 上适配 jdbc-redis 驱动。
- [新增] 恢复 5.x 版本中的 BindTypeHandler 注解。
- [新增] XmlMapper 和 Query 注解，添加 resultTypeHandler 属性可以配置 TypeHandler
- [新增] TypeHandlerColumnRowMapper 可以将 TypeHandler 作为 RowMapper 使用。
- [新增] jdbc-redis 驱动新支持 PING、ECHO、SELECT、INFO 命令。
- [新增] 对于 DataGrip 和 IDEA 内嵌 Database 插件中使用 jdbc-redis 驱动连接 Redis 的支持。
- [优化] 优化 jdbc-redis 驱动支持 ResultSet 的 isLast 方法。
- [优化] 对于部分命令在执行完毕后通过使用 updateCount 方法返回执行结果，这些命令有：
  - HKEYS、HDEL、DEL、SET、HSET、HMSET、HSETNX、EXPIRE、EXPIREAT、PEXPIRE、PEXPIREAT
  - PERSIST、RENAME、RENAMENX、TOUCH、LINSERT、LPUSH、LPUSHX、RPUSH、RPUSHX、LREM、LSET
  - LTRIM、MOVE、SADD、SDIFFSTORE、SINTERSTORE、SMOVE、SREM、SUNIONSTORE、ZDIFFSTORE
  - ZINTERSTORE、ZRANGESTORE、ZREM、ZREMRANGEBYLEX、ZREMRANGEBYRANK、ZREMRANGEBYSCORE
  - ZUNIONSTORE、MSET、MSETNX、PSETEX、SETEX、SETNX、SETRANGE
- [优化] 对于 antlr4 的依赖，内嵌到 jdbc-redis 驱动 jar 包中，以减少外部依赖。
- [优化] 优化 jdbc-redis 驱动报错信息。
- [修复] jdbc-redis 驱动中 Statement 的 getLargeUpdateCount 和 getUpdateCount 没有结果集时会抛出 SQLException 的问题。保持和 jdbc 描述一致，在没有更多结果时返回 -1。
- [修复] jdbc-redis 驱动中 keys 命令无法执行的问题。


## 如何使用?

```java title='使用 JdbcTemplate 存取对象'
// 1. 使用 BindTypeHandler 注释标记 UserInfo 类，指定使用 JsonTypeHandler 来处理该类的序列化和反序列化
@BindTypeHandler(JsonTypeHandler.class)
public class UserInfo {
    ...
}

// 2. 获取 Redis 连接，并构建 JdbcTemplate
Connection redisConn = ...; // 参考文档：驱动适配器 > JDBC Redis > 如何使用
JdbcTemplate jdbc = new JdbcTemplate(redisConn);

// 3. 创建 UserInfo 对象，将其插入到 Redis 中，并使用 Json 序列化存储
UserInfo user = new UserInfo();
user.setUid("j1111");
user.setName("username");
user.setLoginName("login_123");
user.setLoginPassword("password");

// 4. 使用 user_ + uid 作为键名，arg0 为 user 对象
int affected = jdbc.executeUpdate("set #{'user_' + arg0.uid} #{arg0}", user);

// 5. 从 Redis 中查询 UserInfo 对象，并进行反序列化
UserInfo info = jdbc.queryForObject("get #{'user_' + arg0}", "j1111", UserInfo.class);

// 6. 删除 Redis 中的 UserInfo 对象
int deleteCount = jdbc.executeUpdate("del #{'user_' + arg0.uid}", user);
```

```java title='使用 Mapper 注解存取对象'
// 1. 使用 BindTypeHandler 注释标记 UserInfo 类，指定使用 JsonTypeHandler 来处理该类的序列化和反序列化
@BindTypeHandler(JsonTypeHandler.class)
public class UserInfo {
    ...
}

@SimpleMapper()
public interface UserInfo1Mapper {
  // 1. 生成参数化命令：set ? ? 
  // 2. 决定键名：     #{'user_' + info.uid} 
  // 3. 键的值：       #{info}
  @Insert("set #{'user_' + info.uid} #{info}")
  int saveUser(@Param("info") UserInfo info);

  // 1. 生成参数化命令：get ?
  // 2. 决定键名：     #{'user_' + uid}
  @Query("get #{'user_' + uid}")
  UserInfo loadUser(@Param("uid") String uid);

  // 1. 生成参数化命令：del ?
  // 2. 决定键名：     #{'user_' + uid}
  @Delete("del #{'user_' + uid}")
  int deleteUser(@Param("uid") String uid);
}
```

```java title='使用 Mapper File 管理命令(Mapper)'
@RefMapper("dbvisitor_scene/redis/user-mapper.xml")
public interface UserInfoMapper {
  int saveUser(@Param("info") UserInfo info);

  UserInfo loadUser1(@Param("uid") String uid);

  UserInfo loadUser2(@Param("uid") String uid);

  int deleteUser(@Param("uid") String uid);
}
```

```xml title='使用 Mapper File 管理命令(Mapper File)'
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//dbvisitor.net//DTD Mapper 1.0//EN"
        "https://www.dbvisitor.net/schema/dbvisitor-mapper.dtd">
<mapper namespace="net.hasor.scene.UserInfoMapper">
  <insert id="saveUser">
    set #{'user_' + uid} #{info}
  </insert>

  <select id="loadUser" resultType="net.hasor.scene.UserInfo">
    get #{'user_' + uid}
  </select>

  <delete id="deleteUser">
    del #{'user_' + uid}
  </delete>
</mapper>
```