package net.hasor.dbvisitor.driver;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.Statement;
import java.util.Properties;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import static org.junit.Assert.*;

/** Comprehensive tests for JdbcStatement — covers execute, query, update, cancel, properties, and unsupported methods. */
public class JdbcStatementTest {

    private JdbcConnection conn;

    @Before
    public void setUp() throws Exception {
        Class.forName("net.hasor.dbvisitor.driver.JdbcDriver");
        Properties props = new Properties();
        props.setProperty(JdbcDriver.P_ADAPTER_NAME, "mock");
        conn = new JdbcConnection("jdbc:dbvisitor:mock://localhost", props, null);
    }

    @After
    public void tearDown() throws Exception {
        if (conn != null && !conn.isClosed())
            conn.close();
    }

    // ==================== execute ====================
    @Test
    public void executeQuery_test() throws Exception {
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("SELECT id, name FROM test");
        assertNotNull(rs);
        assertTrue(rs.next());
        assertEquals(1, rs.getInt(1));
        rs.close();
        stmt.close();
    }

    @Test
    public void executeUpdate_test() throws Exception {
        Statement stmt = conn.createStatement();
        int count = stmt.executeUpdate("INSERT INTO test VALUES (1)");
        assertEquals(1, count);
        stmt.close();
    }

    @Test
    public void execute_select() throws Exception {
        Statement stmt = conn.createStatement();
        boolean isResult = stmt.execute("SELECT id, name FROM test");
        assertTrue(isResult);
        ResultSet rs = stmt.getResultSet();
        assertNotNull(rs);
        stmt.close();
    }

    @Test
    public void execute_insert() throws Exception {
        Statement stmt = conn.createStatement();
        boolean isResult = stmt.execute("INSERT INTO test VALUES (1)");
        assertFalse(isResult);
        assertEquals(1, stmt.getUpdateCount());
        stmt.close();
    }

    @Test
    public void executeLargeUpdate_test() throws Exception {
        Statement stmt = conn.createStatement();
        long count = stmt.executeLargeUpdate("INSERT INTO test VALUES (1)");
        assertEquals(1L, count);
        stmt.close();
    }

    @Test
    public void execute_withAutoGeneratedKeys() throws Exception {
        Statement stmt = conn.createStatement();
        boolean isResult = stmt.execute("INSERT INTO test VALUES (1)", Statement.NO_GENERATED_KEYS);
        assertFalse(isResult);
        stmt.close();
    }

    @Test
    public void executeUpdate_withAutoGeneratedKeys() throws Exception {
        Statement stmt = conn.createStatement();
        int count = stmt.executeUpdate("INSERT INTO test VALUES (1)", Statement.NO_GENERATED_KEYS);
        assertEquals(1, count);
        stmt.close();
    }

    @Test
    public void executeLargeUpdate_withKeys() throws Exception {
        Statement stmt = conn.createStatement();
        long count = stmt.executeLargeUpdate("INSERT INTO test VALUES (1)", Statement.NO_GENERATED_KEYS);
        assertEquals(1L, count);
        stmt.close();
    }

    // ==================== getMoreResults ====================
    @Test
    public void getMoreResults_test() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.execute("SELECT id, name FROM test");
        try {
            boolean more = stmt.getMoreResults();
            // mock returns single result, no more
        } catch (SQLException ignore) { /* expected - mock may not support nextResult */ }
        stmt.close();
    }

    @Test
    public void getMoreResults_withCurrent() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.execute("SELECT id, name FROM test");
        try {
            boolean more = stmt.getMoreResults(Statement.CLOSE_ALL_RESULTS);
        } catch (SQLException ignore) {
        }
        stmt.close();
    }

    // ==================== properties ====================
    @Test
    public void getConnection_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertSame(conn, stmt.getConnection());
        stmt.close();
    }

    @Test
    public void maxRows_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertEquals(0, stmt.getMaxRows());
        stmt.setMaxRows(100);
        assertEquals(100, stmt.getMaxRows());
        stmt.close();
    }

    @Test
    public void largeMaxRows_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertEquals(0L, stmt.getLargeMaxRows());
        stmt.setLargeMaxRows(100L);
        assertEquals(100L, stmt.getLargeMaxRows());
        stmt.close();
    }

    @Test(expected = SQLException.class)
    public void setMaxRows_negative() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setMaxRows(-1);
    }

    @Test(expected = SQLException.class)
    public void setLargeMaxRows_negative() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setLargeMaxRows(-1L);
    }

    @Test
    public void fetchSize_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertEquals(0, stmt.getFetchSize());
        stmt.setFetchSize(50);
        assertEquals(50, stmt.getFetchSize());
        stmt.close();
    }

    @Test(expected = SQLException.class)
    public void setFetchSize_negative() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setFetchSize(-1);
    }

    @Test
    public void queryTimeout_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertEquals(0, stmt.getQueryTimeout());
        stmt.setQueryTimeout(30);
        assertEquals(30, stmt.getQueryTimeout());
        stmt.close();
    }

    @Test(expected = SQLException.class)
    public void setQueryTimeout_negative() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setQueryTimeout(-1);
    }

    @Test
    public void maxFieldSize_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertEquals(0, stmt.getMaxFieldSize());
        stmt.setMaxFieldSize(1024);
        stmt.close();
    }

    @Test(expected = SQLException.class)
    public void setMaxFieldSize_negative() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setMaxFieldSize(-1);
    }

    @Test
    public void escapeProcessing_test() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setEscapeProcessing(true);
        stmt.close();
    }

    @Test
    public void fetchDirection_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertEquals(ResultSet.FETCH_FORWARD, stmt.getFetchDirection());
        stmt.close();
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void setFetchDirection_reverse() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setFetchDirection(ResultSet.FETCH_REVERSE);
    }

    @Test
    public void setFetchDirection_forward() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);
        stmt.close();
    }

    @Test
    public void resultSetType_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertEquals(ResultSet.TYPE_FORWARD_ONLY, stmt.getResultSetType());
        assertEquals(ResultSet.CONCUR_READ_ONLY, stmt.getResultSetConcurrency());
        assertEquals(ResultSet.HOLD_CURSORS_OVER_COMMIT, stmt.getResultSetHoldability());
        stmt.close();
    }

    @Test
    public void close_and_isClosed() throws Exception {
        Statement stmt = conn.createStatement();
        assertFalse(stmt.isClosed());
        stmt.close();
        assertTrue(stmt.isClosed());
    }

    @Test
    public void closeOnCompletion_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertFalse(stmt.isCloseOnCompletion());
        stmt.closeOnCompletion();
        assertTrue(stmt.isCloseOnCompletion());
        stmt.close();
    }

    @Test
    public void warnings_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertNull(stmt.getWarnings());
        stmt.clearWarnings();
        stmt.close();
    }

    @Test
    public void isPoolable_test() throws Exception {
        Statement stmt = conn.createStatement();
        assertFalse(stmt.isPoolable());
        stmt.setPoolable(false);
        stmt.close();
    }

    @Test
    public void getGeneratedKeys_test() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.execute("INSERT INTO test VALUES (1)");
        ResultSet gk = stmt.getGeneratedKeys();
        // may be null or empty
        stmt.close();
    }

    @Test
    public void cancel_noOp() throws Exception {
        Statement stmt = conn.createStatement();
        // cancel when nothing pending — should not throw
        try {
            stmt.cancel();
        } catch (SQLException ignore) {
        }
        stmt.close();
    }

    // ==================== unsupported ====================
    @Test(expected = SQLFeatureNotSupportedException.class)
    public void setPoolable_true_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setPoolable(true);
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void setCursorName_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.setCursorName("cursor");
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void execute_columnIndexes_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.execute("INSERT INTO test VALUES (1)", new int[] { 1 });
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void execute_columnNames_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.execute("INSERT INTO test VALUES (1)", new String[] { "id" });
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void executeUpdate_columnIndexes_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.executeUpdate("INSERT INTO test VALUES (1)", new int[] { 1 });
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void executeUpdate_columnNames_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.executeUpdate("INSERT INTO test VALUES (1)", new String[] { "id" });
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void executeLargeUpdate_columnIndexes_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.executeLargeUpdate("INSERT INTO test VALUES (1)", new int[] { 1 });
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void executeLargeUpdate_columnNames_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.executeLargeUpdate("INSERT INTO test VALUES (1)", new String[] { "id" });
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void executeLargeBatch_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.executeLargeBatch();
    }

    @Test(expected = SQLFeatureNotSupportedException.class)
    public void addBatch_unsupported() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.addBatch("INSERT INTO test VALUES (1)");
    }

    @Test
    public void clearBatch_noop() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.clearBatch();
        stmt.close();
    }

    @Test(expected = SQLException.class)
    public void checkOpen_afterClose() throws Exception {
        Statement stmt = conn.createStatement();
        stmt.close();
        stmt.executeQuery("SELECT id FROM test");
    }

    @Test
    public void unwrap_test() throws Exception {
        Statement stmt = conn.createStatement();
        try {
            stmt.unwrap(Statement.class);
        } catch (Exception ignore) {
        }
        try {
            stmt.isWrapperFor(Statement.class);
        } catch (Exception ignore) {
        }
        stmt.close();
    }
}
